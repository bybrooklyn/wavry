name: Platform Builds

on:
  pull_request:
  push:
    branches: [main]
    tags: ["v*"]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: platform-builds-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RELEASE_ICON_PATH: crates/wavry-desktop/src-tauri/icons/icon.png
  RELEASE_ICON_NAME: WavryLogo.png
  MACOSX_DEPLOYMENT_TARGET: "14.0"

jobs:
  pre-build:
    name: Prepare build
    runs-on: ubuntu-latest
    outputs:
      wavry_version: ${{ steps.version.outputs.wavry_version }}
      rift_version: ${{ steps.version.outputs.rift_version }}
      delta_version: ${{ steps.version.outputs.delta_version }}
      is_prerelease: ${{ steps.version_policy.outputs.is_prerelease }}
      release_allowed: ${{ steps.version_policy.outputs.release_allowed }}
      already_released: ${{ steps.check_release.outputs.already_released }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse VERSION file
        id: version
        run: |
          WAVRY_V=$(grep "WAVRY" VERSION | awk '{print $2}' | sed 's/^v//')
          RIFT_V=$(grep "RIFT" VERSION | awk '{print $2}' | sed 's/^v//')
          DELTA_V=$(grep "DELTA" VERSION | awk '{print $2}' | sed 's/^v//')
          echo "wavry_version=$WAVRY_V" >> $GITHUB_OUTPUT
          echo "rift_version=$RIFT_V" >> $GITHUB_OUTPUT
          echo "delta_version=$DELTA_V" >> $GITHUB_OUTPUT
          echo "WAVRY_V=$WAVRY_V" >> $GITHUB_ENV
          echo "Extracted Wavry Version: $WAVRY_V"

      - name: Enforce prerelease policy (canary-only)
        id: version_policy
        run: |
          set -euo pipefail
          WAVRY_V="${{ steps.version.outputs.wavry_version }}"
          REF_TYPE="${GITHUB_REF_TYPE:-branch}"

          if [[ "$WAVRY_V" =~ - ]]; then
            if [[ "$WAVRY_V" =~ ^[0-9]+\.[0-9]+\.[0-9]+-canary([.][0-9A-Za-z-]+)*$ ]]; then
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_allowed=true" >> "$GITHUB_OUTPUT"
            else
              if [[ "$REF_TYPE" == "tag" ]]; then
                echo "Unsupported prerelease version on tag push: $WAVRY_V" >&2
                echo "Only -canary prerelease tags are allowed." >&2
                exit 1
              fi
              echo "::warning::Unsupported prerelease version '$WAVRY_V'. Release creation will be skipped."
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_allowed=false" >> "$GITHUB_OUTPUT"
            fi
          else
            if [[ ! "$WAVRY_V" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Invalid stable version format: $WAVRY_V" >&2
              exit 1
            fi
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "release_allowed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if version already released
        id: check_release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ steps.version_policy.outputs.release_allowed }}" != "true" ]]; then
            echo "Release is disabled by version policy for v${{ env.WAVRY_V }}."
            echo "already_released=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          VERSION="v${{ env.WAVRY_V }}"
          if gh release view "$VERSION" >/dev/null 2>&1; then
            echo "Version $VERSION already exists in releases."
            if [[ "${{ github.ref_type }}" == "tag" ]]; then
              echo "Git tag detected, proceeding with build anyway."
              echo "already_released=false" >> $GITHUB_OUTPUT
            else
              echo "Skipping build for existing version."
              echo "already_released=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "Version $VERSION does not exist yet."
            echo "already_released=false" >> $GITHUB_OUTPUT
          fi

  rust-tests:
    name: Rust tests
    needs: pre-build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config protobuf-compiler libsqlite3-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libasound2-dev libx11-dev libxtst-dev libxrandr-dev libxi-dev libevdev-dev libudev-dev libgtk-3-dev libwebkit2gtk-4.1-dev libsoup-3.0-dev libayatana-appindicator3-dev librsvg2-dev libgl-dev
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: rust-${{ runner.os }}-workspace
      - name: Linux display preflight (compile-time)
        if: runner.os == 'Linux'
        run: ./scripts/linux-display-smoke.sh --skip-runtime
      - name: Run tests
        run: cargo test --workspace --locked

  smoke-tests:
    name: Smoke tests
    needs: pre-build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config protobuf-compiler libsqlite3-dev curl
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: rust-${{ runner.os }}-workspace
      - name: Provision Secrets
        run: ./scripts/provision-infrastructure.sh ./secrets
      - name: Gateway Auth Smoke
        run: |
          source ./secrets/wavry.env
          ./scripts/gateway-auth-smoke.sh
      - name: Master/Relay Smoke
        run: |
          source ./secrets/wavry.env
          ./scripts/master-relay-smoke.sh

  linux-wayland-runtime:
    name: Linux Wayland runtime lane
    needs: pre-build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            dbus-x11 \
            weston \
            xdg-desktop-portal \
            xdg-desktop-portal-gtk \
            pipewire \
            libspa-0.2-modules \
            wireplumber \
            pulseaudio-utils \
            gstreamer1.0-tools \
            gstreamer1.0-pipewire \
            gstreamer1.0-plugins-base \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-bad
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Wayland runtime smoke
        run: ./scripts/ci-wayland-runtime.sh

  rust-backend:
    name: Build backend (${{ matrix.suffix }}-${{ matrix.arch }})
    needs: pre-build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            suffix: linux
            arch: x64
            exe: ""
          - os: macos-14
            suffix: macos
            arch: arm64
            exe: ""
          - os: windows-latest
            suffix: windows
            arch: x64
            exe: ".exe"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config protobuf-compiler libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libasound2-dev libx11-dev libxtst-dev libxrandr-dev libxi-dev libevdev-dev libudev-dev libsqlite3-dev libgtk-3-dev libwebkit2gtk-4.1-dev libsoup-3.0-dev libayatana-appindicator3-dev librsvg2-dev libgl-dev
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: rust-${{ runner.os }}-workspace
      - name: Build
        run: cargo build --release --locked -p wavry-master -p wavry-server
      - name: Stage
        shell: bash
        run: |
          mkdir -p ci-artifacts/backend
          bins=(wavry-master wavry-server)
          for b in "${bins[@]}"; do
            src="target/release/${b}${{ matrix.exe }}"
            dst="ci-artifacts/backend/${b}-${{ matrix.suffix }}-${{ matrix.arch }}${{ matrix.exe }}"
            if [[ ! -f "$src" ]]; then
              echo "Expected backend binary missing: $src" >&2
              exit 1
            fi
            cp "$src" "$dst"
          done
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: backend-${{ matrix.suffix }}-${{ matrix.arch }}-v${{ needs.pre-build.outputs.wavry_version }}
          path: ci-artifacts/backend/

  desktop-tauri:
    name: Desktop build (${{ matrix.suffix }}-${{ matrix.arch }})
    needs: pre-build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            suffix: linux
            arch: x64
            exe: ""
          - os: windows-latest
            suffix: windows
            arch: x64
            exe: ".exe"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install Bun
        uses: oven-sh/setup-bun@v2
      - name: Cache frontend dependencies
        uses: actions/cache@v4
        with:
          path: crates/wavry-desktop/node_modules
          key: bun-${{ runner.os }}-${{ hashFiles('crates/wavry-desktop/bun.lock', 'crates/wavry-desktop/package.json') }}
      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config protobuf-compiler libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libasound2-dev libx11-dev libxtst-dev libxrandr-dev libxi-dev libevdev-dev libudev-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev patchelf libwebkit2gtk-4.1-dev libsoup-3.0-dev libgl-dev rpm || sudo apt-get install -y libwebkit2gtk-4.0-dev rpm
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: rust-${{ runner.os }}-workspace
          workspaces: |
            . -> target
            crates/wavry-desktop/src-tauri -> target
      - name: Install frontend dependencies
        working-directory: crates/wavry-desktop
        run: bun install --frozen-lockfile
      - name: Build (Linux bundles)
        if: runner.os == 'Linux'
        working-directory: crates/wavry-desktop
        run: bun run tauri build --bundles appimage,deb,rpm --ci
      - name: Build (Windows binary)
        if: runner.os == 'Windows'
        working-directory: crates/wavry-desktop
        run: bun run tauri build --no-bundle --ci
      - name: Stage Linux desktop bundles
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ci-artifacts/desktop

          appimage_path=""
          deb_path=""
          rpm_path=""
          for root in "target/release" "crates/wavry-desktop/src-tauri/target/release"; do
            if [[ -z "$appimage_path" && -d "$root/bundle/appimage" ]]; then
              appimage_path="$(find "$root/bundle/appimage" -type f -name "*.AppImage" 2>/dev/null | head -n 1 || true)"
            fi
            if [[ -z "$deb_path" && -d "$root/bundle/deb" ]]; then
              deb_path="$(find "$root/bundle/deb" -type f -name "*.deb" 2>/dev/null | head -n 1 || true)"
            fi
            if [[ -z "$rpm_path" && -d "$root/bundle/rpm" ]]; then
              rpm_path="$(find "$root/bundle/rpm" -type f -name "*.rpm" 2>/dev/null | head -n 1 || true)"
            fi
          done

          [[ -n "$appimage_path" ]] || { echo "Missing Linux AppImage bundle" >&2; exit 1; }
          [[ -n "$deb_path" ]] || { echo "Missing Linux DEB bundle" >&2; exit 1; }
          [[ -n "$rpm_path" ]] || { echo "Missing Linux RPM bundle" >&2; exit 1; }

          cp "$appimage_path" "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.AppImage"
          cp "$deb_path" "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.deb"
          cp "$rpm_path" "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.rpm"

          chmod +x "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.AppImage"
          "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.AppImage" --appimage-version >/dev/null
          dpkg-deb --info "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.deb" >/dev/null
          rpm -qip "ci-artifacts/desktop/wavry-desktop-tauri-linux-${{ matrix.arch }}.rpm" >/dev/null

      - name: Stage Windows desktop binary
        if: runner.os == 'Windows'
        shell: bash
        run: |
          mkdir -p ci-artifacts/desktop
          found=""
          for root in "target/release" "crates/wavry-desktop/src-tauri/target/release"; do
            for name in wavry-desktop wavry_desktop; do
              if [[ -f "$root/${name}${{ matrix.exe }}" ]]; then
                cp "$root/${name}${{ matrix.exe }}" "ci-artifacts/desktop/wavry-desktop-${{ matrix.suffix }}${{ matrix.exe }}"
                found="1"
                break
              fi
            done
            if [[ -n "$found" ]]; then
              break
            fi
          done
          if [[ -z "$found" ]]; then
            echo "No desktop binary found in expected output paths" >&2
            exit 1
          fi
          mv "ci-artifacts/desktop/wavry-desktop-${{ matrix.suffix }}${{ matrix.exe }}" \
             "ci-artifacts/desktop/wavry-desktop-tauri-${{ matrix.suffix }}-${{ matrix.arch }}${{ matrix.exe }}"
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.suffix }}-${{ matrix.arch }}-v${{ needs.pre-build.outputs.wavry_version }}
          path: ci-artifacts/desktop/

  android:
    name: Android build
    needs: pre-build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: 'gradle'
      - name: Setup SDK
        uses: android-actions/setup-android@v3
      
      - name: Cache NDK
        id: cache-ndk
        uses: actions/cache@v4
        with:
          path: /usr/local/lib/android/sdk/ndk/26.3.11579264
          key: ndk-26.3.11579264

      - name: Install NDK
        if: steps.cache-ndk.outputs.cache-hit != 'true'
        run: sdkmanager --install "ndk;26.3.11579264" "cmake;3.22.1"
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android, x86_64-linux-android
      
      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: rust-${{ runner.os }}-android
          key: android-target

      - name: Cache cargo-ndk
        id: cache-cargo-ndk
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-ndk
          key: cargo-ndk-${{ runner.os }}-3

      - name: Install cargo-ndk
        if: steps.cache-cargo-ndk.outputs.cache-hit != 'true'
        run: cargo install cargo-ndk

      - name: Build
        run: ./scripts/dev-android.sh --both --release --no-install --no-ndk-install
      - name: Stage
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p ci-artifacts/android
          mobile_apk="$(find apps/android/app/build/outputs -type f -name "app-mobile-release.apk" | head -n 1 || true)"
          quest_apk="$(find apps/android/app/build/outputs -type f -name "app-quest-release.apk" | head -n 1 || true)"

          if [[ -n "$mobile_apk" ]]; then
            cp "$mobile_apk" "ci-artifacts/android/wavry-mobile-android-arm64-release.apk"
          fi
          if [[ -n "$quest_apk" ]]; then
            cp "$quest_apk" "ci-artifacts/android/wavry-quest-android-arm64-release.apk"
          fi

          if [[ -z "$mobile_apk" && -z "$quest_apk" ]]; then
            echo "No expected Android release APKs were produced." >&2
            exit 1
          fi
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: android-arm64-v${{ needs.pre-build.outputs.wavry_version }}
          path: ci-artifacts/android/

  macos-swift:
    name: macOS Swift app
    needs: pre-build
    runs-on: macos-14
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Build
        run: ./scripts/build-macos.sh release
      - name: Validate app bundle safety
        shell: bash
        run: |
          set -euo pipefail
          app_path="dist/Wavry.app"
          
          if [[ ! -d "$app_path" ]]; then
            echo "Native macOS app bundle not found at $app_path" >&2
            exit 1
          fi
          
          # Check for suspicious symlinks that could cause path traversal
          echo "Checking for suspicious symlinks in app bundle..."
          if find "$app_path" -type l | grep -q .; then
            echo "Found symlinks in app bundle:"
            find "$app_path" -type l -ls
            
            # Check if any symlinks point outside the app bundle
            while IFS= read -r symlink; do
              target=$(readlink "$symlink")
              # Absolute paths or .. traversal are suspicious
              if [[ "$target" = /* ]] || [[ "$target" = *".."* ]]; then
                echo "ERROR: Suspicious symlink detected: $symlink -> $target" >&2
                exit 1
              fi
            done < <(find "$app_path" -type l)
            echo "All symlinks are safe (relative paths within bundle)"
          else
            echo "No symlinks found in app bundle"
          fi
          
          # Check for hidden directories that shouldn't be there
          echo "Checking for suspicious hidden directories..."
          suspicious_hidden=$(find "$app_path" -type d -name ".*" ! -name "." ! -name ".." | head -10)
          if [[ -n "$suspicious_hidden" ]]; then
            echo "WARNING: Found hidden directories:"
            echo "$suspicious_hidden"
          fi
          
          # Verify app bundle structure
          echo "Verifying app bundle structure..."
          required_paths=(
            "$app_path/Contents"
            "$app_path/Contents/MacOS"
            "$app_path/Contents/Info.plist"
          )
          for path in "${required_paths[@]}"; do
            if [[ ! -e "$path" ]]; then
              echo "ERROR: Required app bundle path missing: $path" >&2
              exit 1
            fi
          done
          
          echo "App bundle validation passed"
      - name: Stage
        shell: bash
        run: |
          mkdir -p ci-artifacts/macos-app
          app_path="dist/Wavry.app"
          hdiutil create \
            -volname "Wavry" \
            -srcfolder "$app_path" \
            -ov \
            -format UDZO \
            "ci-artifacts/macos-app/wavry-desktop-native-macos-arm64.dmg"
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: macos-app-v${{ needs.pre-build.outputs.wavry_version }}
          path: ci-artifacts/macos-app/

  release:
    name: Create Release
    needs: [pre-build, rust-tests, smoke-tests, linux-wayland-runtime, rust-backend, desktop-tauri, android, macos-swift]
    if: |
      always() &&
      needs.pre-build.result == 'success' &&
      needs.pre-build.outputs.release_allowed == 'true' &&
      (needs.rust-tests.result == 'success' || needs.rust-tests.result == 'skipped') &&
      (needs.smoke-tests.result == 'success' || needs.smoke-tests.result == 'skipped') &&
      (needs.linux-wayland-runtime.result == 'success' || needs.linux-wayland-runtime.result == 'skipped') &&
      (needs.rust-backend.result == 'success' || needs.rust-backend.result == 'skipped') &&
      (needs.desktop-tauri.result == 'success' || needs.desktop-tauri.result == 'skipped') &&
      (needs.android.result == 'success' || needs.android.result == 'skipped') &&
      (needs.macos-swift.result == 'success' || needs.macos-swift.result == 'skipped') &&
      github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Collect release assets
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p release-assets

          # Infrastructure/service binaries.
          for file in artifacts/backend-*/*; do
            base="$(basename "$file")"
            case "$base" in
              wavry-master-*|wavry-server-*)
                cp "$file" "release-assets/$base"
                ;;
            esac
          done

          # Desktop app artifacts (Tauri).
          for file in artifacts/desktop-*/*; do
            base="$(basename "$file")"
            case "$base" in
              wavry-desktop-tauri-*)
                cp "$file" "release-assets/$base"
                ;;
            esac
          done

          # Native macOS app bundle artifacts.
          for file in artifacts/macos-app-*/*; do
            base="$(basename "$file")"
            case "$base" in
              wavry-desktop-native-macos-*.dmg)
                cp "$file" "release-assets/$base"
                ;;
            esac
          done

          # Android release APKs.
          for file in artifacts/android-*/*.apk; do
            base="$(basename "$file")"
            case "$base" in
              wavry-mobile-android-arm64-release.apk|wavry-quest-android-arm64-release.apk)
                cp "$file" "release-assets/$base"
                ;;
            esac
          done

          required=(
            "release-assets/wavry-master-*"
            "release-assets/wavry-server-*"
            "release-assets/wavry-desktop-tauri-linux-*.AppImage"
            "release-assets/wavry-desktop-tauri-linux-*.deb"
            "release-assets/wavry-desktop-tauri-linux-*.rpm"
            "release-assets/wavry-desktop-tauri-windows-*.exe"
            "release-assets/wavry-desktop-native-macos-*.dmg"
            "release-assets/wavry-mobile-android-arm64-release.apk"
            "release-assets/wavry-quest-android-arm64-release.apk"
          )
          for pattern in "${required[@]}"; do
            if ! compgen -G "$pattern" > /dev/null; then
              echo "Missing required release asset matching: $pattern" >&2
              exit 1
            fi
          done

          forbidden=(
            "release-assets/wavry-gateway-*"
            "release-assets/wavry-relay-*"
            "release-assets/wavry-desktop-tauri-macos-*"
          )
          for pattern in "${forbidden[@]}"; do
            if compgen -G "$pattern" > /dev/null; then
              echo "Forbidden release asset present (policy violation): $pattern" >&2
              exit 1
            fi
          done

          count="$(find release-assets -type f | wc -l | tr -d ' ')"
          if [[ "$count" == "0" ]]; then
            echo "No release assets were collected." >&2
            exit 1
          fi
      - name: Checksums
        run: |
          cd release-assets
          find . -type f -exec sha256sum {} + > ../SHA256SUMS.txt
      - name: Generate asset manifest
        shell: bash
        run: |
          {
            echo "# Wavry Release Assets"
            echo
            echo "| File | Category | Platform | Architecture | Purpose |"
            echo "|---|---|---|---|---|"
            while IFS= read -r file; do
              category="Other"
              platform="Unknown"
              arch="Unknown"
              purpose="Release artifact"
              case "$file" in
                wavry-master-*)
                  category="Backend Service"
                  platform="${file#wavry-master-}"
                  platform="${platform%-*}"
                  arch="${file##*-}"
                  arch="${arch%.exe}"
                  purpose="Master coordination service binary"
                  ;;
                wavry-server-*)
                  category="Backend Service"
                  platform="${file#wavry-server-}"
                  platform="${platform%-*}"
                  arch="${file##*-}"
                  arch="${arch%.exe}"
                  purpose="Host runtime service binary"
                  ;;
                wavry-desktop-tauri-linux-*.AppImage)
                  category="Desktop App"
                  platform="Linux"
                  arch="${file#wavry-desktop-tauri-linux-}"
                  arch="${arch%.AppImage}"
                  purpose="Portable Tauri desktop build (AppImage)"
                  ;;
                wavry-desktop-tauri-linux-*.deb)
                  category="Desktop App"
                  platform="Linux"
                  arch="${file#wavry-desktop-tauri-linux-}"
                  arch="${arch%.deb}"
                  purpose="Debian/Ubuntu installable package (.deb)"
                  ;;
                wavry-desktop-tauri-linux-*.rpm)
                  category="Desktop App"
                  platform="Linux"
                  arch="${file#wavry-desktop-tauri-linux-}"
                  arch="${arch%.rpm}"
                  purpose="Fedora/RHEL installable package (.rpm)"
                  ;;
                wavry-desktop-tauri-windows-*.exe)
                  category="Desktop App"
                  platform="Windows"
                  arch="${file#wavry-desktop-tauri-windows-}"
                  arch="${arch%.exe}"
                  purpose="Tauri desktop executable"
                  ;;
                wavry-desktop-native-macos-*.dmg)
                  category="Desktop App"
                  platform="macOS"
                  arch="${file#wavry-desktop-native-macos-}"
                  arch="${arch%.dmg}"
                  purpose="Native Swift desktop disk image (DMG)"
                  ;;
                wavry-mobile-android-arm64-release.apk)
                  category="Android App"
                  platform="Android"
                  arch="arm64"
                  purpose="Mobile Android client release APK"
                  ;;
                wavry-quest-android-arm64-release.apk)
                  category="Android App"
                  platform="Android (Quest)"
                  arch="arm64"
                  purpose="Quest Android client release APK"
                  ;;
              esac
              echo "| \`$file\` | $category | $platform | $arch | $purpose |"
            done < <(find release-assets -maxdepth 1 -type f -printf '%f\n' | sort)
          } > RELEASE_ASSETS.md
      - name: Generate docker image manifest
        shell: bash
        run: |
          {
            echo "# Wavry Docker Images"
            echo
            echo "Control-plane services are Docker-only."
            echo
            echo "## Images"
            echo
            echo "- \`ghcr.io/${{ github.repository }}/gateway\`"
            echo "- \`ghcr.io/${{ github.repository }}/relay\`"
            echo
            echo "## Recommended Tags"
            echo
            echo "- Release-pinned: \`v${{ needs.pre-build.outputs.wavry_version }}\`"
            echo "- Mainline environments: \`main\` or \`latest\`"
          } > DOCKER_IMAGES.md
      - name: Delete existing release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ needs.pre-build.outputs.wavry_version }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            gh release view "$TAG" --json assets --jq '.assets[].name' \
              | xargs -I{} gh release delete-asset "$TAG" "{}" --yes 2>/dev/null || true
          fi
      - name: GH Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.pre-build.outputs.wavry_version }}
          name: Wavry v${{ needs.pre-build.outputs.wavry_version }}
          generate_release_notes: false
          allow_updates: true
          prerelease: ${{ needs.pre-build.outputs.is_prerelease == 'true' }}
          body: |
            ## Version Matrix
            - **Wavry Core:** `v${{ needs.pre-build.outputs.wavry_version }}`
            - **RIFT Protocol:** `v${{ needs.pre-build.outputs.rift_version }}`
            - **DELTA Congestion Control:** `v${{ needs.pre-build.outputs.delta_version }}`

            ## Asset Naming
            All assets use explicit names:
            `<component>-<variant>-<platform>-<arch>[.<ext>]`

            ## Control Plane Containers (Docker-Only)
            - **Gateway auth/control plane:** `ghcr.io/${{ github.repository }}/gateway`
            - **Relay service:** `ghcr.io/${{ github.repository }}/relay`
            - For tagged releases, use image tag `v${{ needs.pre-build.outputs.wavry_version }}`.

            ## Download Guide
            - **Linux desktop:** download one of
              - `wavry-desktop-tauri-linux-x64.AppImage` (portable)
              - `wavry-desktop-tauri-linux-x64.deb` (Debian/Ubuntu)
              - `wavry-desktop-tauri-linux-x64.rpm` (Fedora/RHEL)
            - **Windows desktop:** `wavry-desktop-tauri-windows-x64.exe`
            - **macOS desktop (Native Swift):** `wavry-desktop-native-macos-arm64.dmg`
            - **Backend binaries:** `wavry-master-*`, `wavry-server-*`
            - **Android:** `wavry-mobile-android-arm64-release.apk`, `wavry-quest-android-arm64-release.apk`

            ## Integrity and Catalog
            - `SHA256SUMS.txt` contains checksums for every shipped file.
            - `RELEASE_ASSETS.md` is the full labeled asset catalog.
          files: |
            release-assets/*
            SHA256SUMS.txt
            RELEASE_ASSETS.md
            DOCKER_IMAGES.md
